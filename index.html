<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录一些想法和技术问题">
<meta property="og:type" content="website">
<meta property="og:title" content="欧泡的摸鱼日记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="欧泡的摸鱼日记">
<meta property="og:description" content="记录一些想法和技术问题">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="欧泡果奶欧欧欧">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>欧泡的摸鱼日记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">欧泡的摸鱼日记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/game_theory_0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/game_theory_0/" class="post-title-link" itemprop="url">游戏常识0——数值模型（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-21 13:25:00 / 修改时间：13:30:51" itemprop="dateCreated datePublished" datetime="2022-03-21T13:25:00+08:00">2022-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">游戏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>逛各种游戏社区时经常需要一遍遍地科普游戏常识，索性整理一下写(shui)几篇博客。内容不会很深，仅作科普用。</p>
<p>先从通用数值模型说起吧。</p>
<hr>
<h2 id="如何评估一名角色的战斗力"><a href="#如何评估一名角色的战斗力" class="headerlink" title="如何评估一名角色的战斗力"></a>如何评估一名角色的战斗力</h2><p>一个显而易见的原则：我打得过你，说明我的战斗力(下称$\color{green}{power}$)高于你，反之亦然。</p>
<p>但是游戏机制千变万化，各种克制关系和玩家操作的影响使得上述原则难以实际量化。为此，我们首先需要简化游戏的数值模型，以此为原型进行讨论并逐步添加其他条件。该模型如下：</p>
<ol>
<li>角色仅有每秒输出（下称$ \color{green}{dps} $）与生命值（下称$\color{green}{hp}$）两个属性，我们使用其二元组描述一个角色，如A(x,y)表示角色A每秒输出为x，生命值为y；</li>
<li>以战斗开始为时刻0，角色互相攻击，以自身dps为速率（连续）降低敌方生命值，当某一方死亡时战斗结束；</li>
<li>角色不能移动或逃跑。</li>
</ol>
<p>这样的模型下，如何通过dps与hp判断角色A是否能够击败角色B（角色A的战斗力是否高于角色B）？很简单，角色A在被角色B击杀之前能够击杀角色B即可，也就是角色A在死亡前能够打出的总输出高于角色B的生命值，也就是：</p>
<script type="math/tex; mode=display">\ damage(A) = dps(A)t(A)=\frac {dps(A)hp(A)}{dps(B)}>hp(B)</script><p>即：</p>
<script type="math/tex; mode=display">\ dps(A)hp(A) > dps(B)hp(B)</script><p>因此，我们可以用dps*hp作为一个角色的战力标准。如：power(A(1,3))=3&lt;power(B(2,2))=4,故角色A打不过角色B。</p>
<hr>
<h2 id="数值稀释，战斗力乘区"><a href="#数值稀释，战斗力乘区" class="headerlink" title="数值稀释，战斗力乘区"></a>数值稀释，战斗力乘区</h2><p>在游戏内我们的资源是有限的，这里的资源可以是金币，装备栏位等各种能够提升属性的东西。将其抽象简化后，我们可以定义其为技能点（下称$\color{green}{point}$):用于提升属性的资源，一个单位的技能点可以提升一个单位的任意属性。如果我们将(1,1)定为单位战斗力模型，那么我们有：</p>
<script type="math/tex; mode=display">\ point=(dps-1)+(hp-1)</script><p>这引入了一个问题：怎样分配技能点可以使战斗力最大化？由前的计算面可以看出，A(1,3)与B(2,2)有着相同的技能点数2，但是战斗力不同。</p>
<p>考虑这样一个极端模型：(1，100)，战斗力为100。如果我们手上有一个point，将其分配到dps上，那么属性变为(2,100)，战斗力变为200，提升了100%；转而将其分配到hp上，属性变为(1,101)，战斗力变为101，仅提升1%。</p>
<p>这就是我们常说的稀释：由于先前分配了太多技能点在同一属性上，继续提升该属性能够得到的收益越来越低，也就是在该属性上新分配的技能点起到的作用被“稀释”了。</p>
<p>事实上，通过基本不等式我们能够很简单地得到一个结论：尽量使dps与hp相同能够最大化战斗力（这里的“相同”是对于简化模型来说的，实际游戏中应乘以某一比例系数），也就是说需要将技能点分配给最薄弱的属性。</p>
<p>如果我们将dps细分为两项：攻击力(下称$\color{green}{atk}$)与攻击速度(下称$\color{green}{spd}$)，即dps=atk*spd，那么我们的战斗力公式变为：</p>
<script type="math/tex; mode=display">\ power=dps*hp=atk*spd*hp</script><p>此时我们在上面的推论仍然适用，也就是将技能点分配给最低的属性收益是最高的。事实上，我们可以推广至一般情形：如果战斗力可以分为N个属性相乘：</p>
<script type="math/tex; mode=display">\ power=property_1*property_2*......*property_N</script><p>那么在这N个属性上平均分配技能点的收益是最高的。</p>
<p>上面的描述有一个不严谨的地方：不同属性对战斗力影响的关系未必全部都是相乘。譬如，某个角色的普通攻击为物理伤害，假设裸装下其dps为1；我们现在给他两个词条，一是“物理伤害增加100%”，二是“普通攻击伤害增加100%”，请问他此时的dps为？</p>
<p>可以是1<em>(1+100%+100%)=3，也可以是1</em>(1+100%)*(1+100%)=4，取决于游戏机制。</p>
<p>因此，我们再次修正战斗力模型如下：</p>
<script type="math/tex; mode=display">\ power=(1+property_{11}+property_{12}+......)*(1+property_{21}+property_{22}+......)*.......</script><p>在上面的公式中，如果第一个括号内的和非常大，那么即使$property<em>{11}$的值很小，我们将技能点分配给$property</em>{11}$的收益也是很低的。可以发现我们之前的推论仍然在生效，只不过从“尽量使各属性相同”变为“尽量使各括号内的值相同”。我们把每个括号称作一个乘区，称在同一个括号内的两个属性“在同一个乘区”。同一个乘区内的属性会相互稀释。</p>
<p>如何判断两个属性是否在一个乘区内呢？仍然以上面的物理伤害与普通攻击伤害词条为例。两个词条的卸下/佩戴状态共有四种组合方式，在四种组合方式下分别打出一次攻击并记录伤害，列出矩阵：</p>
<script type="math/tex; mode=display">
\begin{array}{c|lcr}
伤害 & \text{无物理词条} & \text{有物理词条} \\
\hline
无普攻词条 & d_{00} & d_{01} \\
有普攻词条 & d_{10} & d_{11} \\
\end{array}</script><p>证明过程略，直接说结论：如果两个词条在不同乘区，那么它们对应的行/列向量线性相关。对于上述矩阵，其行列式为0，即：</p>
<script type="math/tex; mode=display">\ d_{00}d_{11}-d_{10}d_{01}=0</script><hr>
<h2 id="杂谈的杂谈"><a href="#杂谈的杂谈" class="headerlink" title="杂谈的杂谈"></a>杂谈的杂谈</h2><p>本文提及的战斗力数学模型并不适用于所有游戏。个人经验表明：伤害计算越复杂、数字越大的游戏与该模型的契合度越好，例如暗黑三，DNF，原神等（伤害以万甚至亿为单位）；而对于MOBA类游戏（伤害在几百上千的范畴），职业定位、角色技能与个人操作起到了更为关键的作用，上述模型能够起到的作用比较有限；对于旷野之息、MC等游戏（伤害通常在个位数到几十点），该模型的描述能力接近于0。</p>
<p>另一方面，不同属性的获取难度是有区别的，因此具有独立乘区并且少见的属性就十分吃香。没错，我说的就是易伤。所以经常能够看见百分之四十几物伤加成词条不如百分之十几的易伤词条优先级高的情况。</p>
<p>另外，相比于不出暴击的角色，出暴击本身平白多出两个乘区（暴率和暴伤）。但暴率是个特殊的乘区：它没有基础值，这就意味着暴率叠起来之前暴伤作用很小。因此，暴击装备往往在后期表现出色。</p>
<p>先写到这里，其余内容下次再更吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/graduation_project_design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/graduation_project_design/" class="post-title-link" itemprop="url">毕设—简介与规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 23:43:00" itemprop="dateCreated datePublished" datetime="2022-03-19T23:43:00+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-20 23:05:20" itemprop="dateModified" datetime="2022-03-20T23:05:20+08:00">2022-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">毕业设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="现代机械臂相关技术简介"><a href="#现代机械臂相关技术简介" class="headerlink" title="现代机械臂相关技术简介"></a>现代机械臂相关技术简介</h2><p>机械臂是指高精度，多输入多输出、高度非线性、强耦合的复杂系统。因其独特的操作灵活性，已在工业装配、安全防爆等领域得到广泛应用。</p>
<p>机械臂是一个复杂系统，存在着参数摄动、外界干扰及未建模动态等不确定性。因而机械臂的建模模型也存在着不确定性，对于不同的任务，需要规划机械臂关节空间的运动轨迹，从而级联构成末端位姿。</p>
<p>机械臂，或者说机器人技术是机电技术的一种。涉及的知识领域有电子技术（包括数电、模电、单片机编程、PCB设计等）、机械原理/机械设计、电机学、力学、线性代数等内容。</p>
<h2 id="项目简介，总体框架与技术栈"><a href="#项目简介，总体框架与技术栈" class="headerlink" title="项目简介，总体框架与技术栈"></a>项目简介，总体框架与技术栈</h2><p>本项目题为《6自由度机械臂运动控制系统的设计与实现》，旨在实现一个高灵活性、可编程、支持有线与无线连接、功能丰富的机械臂系统。</p>
<p>项目通过摄像头获取手部姿态数据，经过处理后转化为关节角度，并通过蓝牙或串口发送给控制芯片，进而转化为模拟信号控制电机驱动关节旋转。预期实现的功能有：蓝牙/串口通信，机器人动画配置，同步人手动作，通过上位机程序手动调节各关节角度等。</p>
<p>上位机程序支持安卓与Windows两个平台。</p>
<p>项目用到的技术栈结构如下：</p>
<p><img src="/.com//tech_stack.png" alt="技术栈结构"></p>
<h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><p>进度点：</p>
<p><img src="/.com//task_flow.png" alt="进度点"></p>
<p>当前进度：1.3/2.3 + 2.4</p>
<h3 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h3><ol>
<li>可视化界面：能够直观地看见机械臂的关节+连杆结构，能够调节各个活动单元的参数并实时反映在界面上，能够通过配置启动文件修改关节的初始参数/结构。</li>
<li>手势识别模块：接入谷歌的Mediapipe手势识别算法，通过摄像头获取手势数据并转化为机械臂参数。</li>
<li>通过手势识别控制单个舵机：打通人手到电机的数据流，初步实现电机动作与手部的同步。</li>
<li>添加动画功能与文件系统：通过设置关键帧的功能实现动画系统，使机械臂能够执行一系列指定动作；动画文件与机械臂初始化文件需要一个统一的上位机文件管理系统。</li>
<li>移植手势识别模块至安卓：接入Mediapipe的Android SDK，以在Android平台上运行上位机程序（程序的其他部分由U3D开发，本身就具备跨平台特性）。</li>
<li>添加蓝牙通信模块与控制模式选择：在串口通信外添加蓝牙通信功能，其协议匹配下位机通信协议；添加手动赋值/播放动画/串口通信/蓝牙通信四个控制模式的切换功能。</li>
<li>在手机上使用手势识别控制机械臂：准确来说为安卓手机。将手势识别的数据通过蓝牙发送至下位机，并控制电机从而同步人手动作。</li>
</ol>
<h3 id="下位机"><a href="#下位机" class="headerlink" title="下位机"></a>下位机</h3><ol>
<li>STM32基础知识学习：简单了解STM32原理、功能与使用。</li>
<li>舵机驱动，串口通信：学习相关内容与原理，打通上位机与电机间的数据通路。</li>
<li>通过手势识别控制单个舵机：同1.3。</li>
<li>机器人运动学：学习机器人正逆运动学、动力学、路径规划算法等内容。</li>
<li>机械结构选择，确定DH参数：选择合适的机械结构，测量其参数以建立DH运动学模型。</li>
<li>添加HC-05蓝牙模块：通过HC-05为单片机增加无线通信功能。</li>
<li>同1.7。</li>
</ol>
<h2 id="未提及的功能"><a href="#未提及的功能" class="headerlink" title="未提及的功能"></a>未提及的功能</h2><p>这部分功能不在任务规划内，但是时间充裕的话会加入到机械臂功能中，包括但不限于：</p>
<ol>
<li>更换舵机为无刷/步进电机以获得更高的精度与更强的力矩；</li>
<li>（基于1）检测电机的位置/电流等参数；</li>
<li>（基于1）添加减速器以获得更强的力矩与更高的精度；</li>
<li>（基于2）添加PID回路系统以获得更好的控制效果；</li>
<li>（基于2）添加反向数据通道，使上位机同步机械臂的实际动作；</li>
<li>（基于5）将动作同步功能添加至动画系统中以实现示教功能；</li>
<li>添加AR功能；</li>
<li>添加炫酷的粒子特效；</li>
<li>添加更复杂的模型；</li>
</ol>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><ol>
<li>上位机程序仓库地址：暂未上传</li>
<li>下位机程序仓库地址：暂未上传</li>
<li>参考资料： 待更新</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/meta_blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/meta_blog/" class="post-title-link" itemprop="url">MetaBlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 13:29:00" itemprop="dateCreated datePublished" datetime="2022-03-19T13:29:00+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-20 23:05:38" itemprop="dateModified" datetime="2022-03-20T23:05:38+08:00">2022-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">杂谈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我的中学时代，我没有哪怕一本错题集或笔记本。偶尔会有任课老师硬性要求，我也仅仅是草草应付了事，一两个礼拜后便抛诸脑后。在我看来，把三角函数在30°/45°/60°的值做成表格抄在本子上的行为是不可理喻的，明明是画个图按勾股定理算一遍就能直观看到的数字。用多了之后，画图的部分也能够省略，自然而然地背下这些常用数值。</p>
<p>这种情况在我开始学习各种计算机技术时开始发生改变。各种环境搭建千人千坑，各种开发环境的API多如牛毛。如果没有记录，在新的PC上很可能要花费大量的时间来同步环境，在使用API时要反复谷歌。</p>
<p>于是我开始记录这些东西，先是一些简单的txt，随后进行整理按领域分成几个文件夹存到U盘，后来开始写博客。</p>
<p>根本区别是“技”与“术”的区别。中学时代学习的是知识，是通用的“术”，重在理解。而各种软硬件/编程语言/操作系统则是技能，是人造的“技”，其使用方式不作记录很容易忘掉。</p>
<p>在一段时间后，我的观点又发生了变化。以学生的视角看，以笔记来帮助“技”的学习是必要的，但以开发者/工程师的角度则不然：如果某个工具你经常用到，那你自然能够背下其使用方式；如果这个工具你不常用到，那么你也不需要背。</p>
<p>所以我在博客中不再记录各种详细的配置步骤与API的介绍（虽然在我自己的学习过程中同类型的博客给了我很大的帮助），只简单叙述配置过程中自己遇到的坑。而博客的重心，也从操作转变为对技术本身的理解与思考。</p>
<p>我希望自己的博客能够更加贴近“术”的层面。只有能够用自己的语言向别人讲述一个技术的来龙去脉，才算是以设计者的角度真正理解了工具。几年后再回首，也许会为此时的粗浅理解感到羞耻，那时或许会再清空一波博客？</p>
<p>但是脑海里的知识和技能不会一同清空，它们记录着我此时的思考。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/stm32_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/stm32_2/" class="post-title-link" itemprop="url">STM32学习笔记_2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 13:29:00" itemprop="dateCreated datePublished" datetime="2022-03-19T13:29:00+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 02:08:02" itemprop="dateModified" datetime="2022-03-21T02:08:02+08:00">2022-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GPIO、串口与PWM是我与上位机通信/控制舵机所需的所有IO模式，所以这应该是我最后一篇STM32学习博客。（如果之后将与上位机的通信方式从蓝牙改为wifi可能会再写一篇）。</p>
<h2 id="STM32的中断"><a href="#STM32的中断" class="headerlink" title="STM32的中断"></a>STM32的中断</h2><p>中断及中断嵌套的概念不再复述。</p>
<p>STM32使用内核外设NVIC进行中断嵌套的控制。NVIC支持84个中断源（16内核中断+68外部中断，随芯片型号可能有删减）。除了系统内核的中断外，其余中断均可配置一个主优先级与一个副优先级。主优先级高的中断可以打断主优先级低的中断，进行中断嵌套，否则无法打断，进入中断等待队列。当一个中断函数处理完成后，从中断等待队列中选择副优先级最高的中断进行处理。若副优先级相同，则选择中断号最小的中断进行处理。</p>
<p>上面的内容是大多教程/文档给出的说法。这里有几个问题：同一中断源反复触发（在第一次中断还没有执行完成的情况下），是否会在中断等待队列中添加多个相同元素？中断等待队列的最大长度是多少？超出长度时出现新的中断如何处理？从中断等待队列中取元素时是否考虑主中断优先级？</p>
<p>这些问题等我查阅手册后再作解答，先回到STM32中断的配置。</p>
<p>主优先级与副优先级共用四个位（可能是NVIC的体积限制）。这四个位如何分配？主副优先级各占几位？这取决于NVIC的配置，从主4副0到主0副4共有5种分配方式。注意这个分配是全局的，不能对每个中断源单独分组，一个芯片只能使用一个分组方案。</p>
<p>每一个GPIO都可以作为外部中断源使用。中断触发方式分为高电平触发/低电平触发/上升沿触发/下降沿触发等。但GPIO引脚众多，仅仅68个外部中断如何分配？答案是引脚分组，尾号相同的引脚分在同一组，如PA0、PB0、PC0、PD0处于同一组。</p>
<p>简单聊一聊中断：</p>
<p>在初见NVIC时我感到十分疑惑：内核外设？为什么会有这种说法？外设为什么要放在内核里？在经过一段时间的学习和思考后，我理解了其原因：中断处理只能放在内核进行。如果内核不提供中断处理的接口，仅凭片上外设是无法完成中断操作的（也不绝对，接下来会提到），单步调试同理。</p>
<p>中断是CPU提供给外设的接口，常常与轮询、DMA、通道放在一起作比较，这里谈一谈中断与轮询。</p>
<p>上一篇博客中提到，片上外设的本质是替CPU分担部分常见封装工作。因此，当CPU与多个外设共同运行时，我们其实可以把单片机看作是一个多核CPU，其中外设核执行着它们封装的线程。主线程设定好外核线程的参数，随后等待其处理完毕回送数据。而主线程无法预知外设线程什么时候回传数据，因此有了轮询方式，阻塞CPU直到数据回传：</p>
<pre><code>while(CheckState() == State.Waiting)
    ;
//do sth...
</code></pre><p>如果我的主逻辑是一个while(true)循环，那么我可以把上面的等待逻辑嵌入到主逻辑中，从而达到不阻塞主逻辑的效果：</p>
<pre><code>while(1)
&#123;
    MainLogic();
    if(CheckState() == State.Succeed)
    &#123;
        //do sth...
    &#125;
&#125;
</code></pre><p>我以前用51写贪吃蛇时使用的就是这样的方式，在不阻塞主线程的情况下检测按键的落下/抬起。到这里，已经有了一丝中断的影子。</p>
<p>这里的问题在于，if语句是否会执行、执行间隔是多少取决于MainLogic的实现。里面可能是几个简单的计算赋值语句，也可能需要进行一个排序操作，甚至可能直接阻塞。另一方面，按键输入处理函数也有同样的问题。如果按键输入处理函数阻塞，那么我们将无法返回代码主逻辑。</p>
<p>一个解决方案是将MainLogic细分为几个原子操作，类似这样：</p>
<pre><code>int state = 0;
void MainLogic0()
&#123;
    //do sth...
&#125;
void MainLogic1()
&#123;
    //do sth...
&#125;
......
void MainLogic()
&#123;
    switch(state)
    &#123;
        case 0:
            MainLogic0();
            state = 1;
            break;
        case 1:
            MainLogic1();
            state = 2;
            break;
        ......
    &#125;
&#125;
</code></pre><p>顺序结构的细分十分简单，分支与循环结构的细分相对复杂，而函数的调用只需要保证所有子函数进行了同样的细分就能很轻易地完成。但是，细分粒度的控制依旧是人为处理，麻烦的同时可靠性与可读性低。</p>
<p>一个更合理的解决方案是从编译器下手，将CheckState语句插入到机器指令中（在Unity的热更插件IFix中有类似的“打桩”操作），每执行几条机器指令执行一次中断检测处理函数。在中断检测处理函数中读写我们设置的中断触发寄存器，中断嵌套栈等内容，就真正完成了一套纯软件的中断系统。</p>
<p>（以上分析在许多细节处的可行性略存疑，不过大致是这么个思路。）</p>
<p>如果更进一步呢？如果我们每执行一个机器指令进行一次中断检测呢？如果把中断检测与中断嵌套、跳转控制交由专门的硬件进行呢？这就是CPU内核中断控制与NVIC了。</p>
<p>在大一第一次听说中断的概念时，我经过分析得出一个结论：中断的关键在于触发器，CPU中断控制的底层必然以某个触发器作为关键元件。所以在学习微原时我理所当然地懵了：这不还是轮询吗，只是把轮询交由硬件实现并强制每个周期执行一次而已。</p>
<p>事实上也的确如此，内核中断检测+NVIC本质上还是对软件能够实现的功能提供了硬件封装，从而提高效率。另一方面，即使是机器指令插桩的方式也无法完美控制细分粒度，而将中断检测放在CPU周期里则可以，这是软件所无法做到的。</p>
<h2 id="定时器与PWM"><a href="#定时器与PWM" class="headerlink" title="定时器与PWM"></a>定时器与PWM</h2><p>定时器本质上就是一个计数器，累加到设定值后清零/累减到0后重载为设定值，同时发出一个时钟周期的脉冲信号，数电课程里有详细描述其电路设计。这个脉冲信号可以用作中断，从而实现精确的定时操作。</p>
<p>STM32中有若干基础定时器，通用定时器与高级定时器，其功能逐步递增。由于定时器的频率需求多种多样，可能与系统频率/总线频率都不同，所以又为每个定时器分配了一个分频器。</p>
<p>基础定时器的配置相对简单，几个参数（分频值，重载值，是否使能中断）都比较清晰明了。</p>
<p>而在基础定时器上再添加一个寄存器与比较电路，就能够生成一个占空比可调的周期脉冲方波，这就是通用定时器相比基础定时器多出的功能（还有一些其他功能，这里不再深入）。一个通用定时器可以产生4路方波脉冲输出，它们的占空比可以单独进行调制。</p>
<p>调制方波占空比的技术被称为脉冲宽度调制，即PWM，在电机控制中被广泛运用。</p>
<p>以下为我对PWM的见解：</p>
<p>PWM本质上是一个DAC转换器，将数字信号转变为了模拟信号。在调试PWM输出时，可以直接用万用表测量其电压。如PWM高电平为5V，低电平为0V，用电压表测得输出口电压为2V，则可以判断其占空比为40%。</p>
<p>但是这种转换方式十分简单粗暴。假设数字信号调制的周期为t，PWM的脉冲周期为nt，那么其占空比可以为0/n、1/n、2/n……n/n共n+1种状态，而nt的时间内通过调制数字信号能够输出的不同状态数量最大为2^n个，也就是说通信速率的利用率实际上只有(n+1)/(2^n)，而通常为了提高电机的精度，n取值一般较大（在机械臂中更是如此。如果某个关节与末端执行器距离为1m，那么0.1°的关节误差就会导致末端执行器偏移足足0.5mm），这就会导致带宽损失接近指数级增长。</p>
<p>其优点为解码电路简单，以我有限的知识最简单粗暴的解码方式就是加个低通滤波，完全不需要任何芯片就能将PWM信号转变为较稳定的模拟电压信号。解码电路简单导致了成本的降低、稳定性的提高与体积的缩小。</p>
<p>但以我的理解，电机完全可以只接收模拟电平信号，将ADC的功能部分交给控制板完成。这样，我既可以接个PWM解码外设继续使用低成本的PWM电路，也可以使用更为复杂精细的DAC-ADC芯片。这样做的好处还有很多，为什么业界最终采用了将PWM解码做进电机的方案？</p>
<p>也许这个问题要再学习个几年才能得到解答了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/18/stm32_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/18/stm32_1/" class="post-title-link" itemprop="url">STM32学习笔记_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-18 23:15:00" itemprop="dateCreated datePublished" datetime="2022-03-18T23:15:00+08:00">2022-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 02:08:52" itemprop="dateModified" datetime="2022-03-21T02:08:52+08:00">2022-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>鸽了两天，主要是被一些奇奇怪怪的坑给卡住了<br>解决之后（其实没有完全解决）回来继续写点东西</p>
<hr>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>即通用输入/输出口，获取/输出数字电平状态。</p>
<p>在STM32中，GPIO的输入/输出各有四种状态，不作详细说明（其实是因为我也不太懂，上/下拉输入输出对我来说够用了）。</p>
<p>GPIO作为输入时可以用作中断触发源，常用于按键中断。</p>
<p>与51不同，由于时钟树与多种IO模式的存在，GPIO在使用前需要进行相关的配置。</p>
<p>以下为我对GPIO的个人理解：</p>
<p>结合上一篇博客的内容，我们可以将STM32芯片抽象为如下模型：对4GB内存空间内的各个寄存器进行读写，最终控制144个引脚（随型号不同可能有删减）的电平进行读写。</p>
<p>使用GPIO是直接对引脚的电平进行读写，而使用其他片上外设是通过特定的协议对引脚进行间接读写。因此，片上外设相当于对引脚的一层封装。</p>
<p>而这种封装同样可以使用代码进行。比较经典的是delay函数的实现，通过执行nop操作可以达到和定时器一样的效果。</p>
<p>缺点也很明显，nop操作会大量占用CPU资源。因此，片上外设的本质是通过封装一些常用协议，从而使用简单的电路替CPU完成一些操作，从而挤出更多运算资源。</p>
<h2 id="从寄存器到CubeMX"><a href="#从寄存器到CubeMX" class="headerlink" title="从寄存器到CubeMX"></a>从寄存器到CubeMX</h2><p>首先吐槽一下寄存器这个叫法，我学习的时候满脑子都是汇编的r0, ds, pc, ax什么的，疑惑着为什么寄存器会有内存地址。</p>
<p>寄存器需要这样理解：对于外设这是寄存器，而对于CPU他只是诸多内存单元中的一个，应当看作内存处理。</p>
<p>GPIO操作的流程是：先进行相关配置（时钟配置，IO模式配置），然后对GPIO的控制寄存器对应的内存地址进行读写。</p>
<p>事实上，所有的外设都是这样一套流程。上一篇博客中提到，STM32编程本质上就是对内存单元进行操作从而控制自己想要控制的外设。</p>
<p>操控哪些内存单元？如何操纵这些内存单元（每个字节每个位具体的含义是什么）？这就需要翻阅STM32文档了。</p>
<p>因此，最终的代码看上去会是像这样：</p>
<pre><code>//初始化时钟
*(unsigned int *)内存地址0 = 值0；
//将IO口xx设置为推挽输出模式
*(unsigned int *)内存地址1 = (值1  &amp;&amp; xxxx) || (yyyy &lt;&lt; zzzz)；
//将IO口xx设置为低电平
*(unsigned int *)内存地址2 = 值2；
......
</code></pre><p>可维护性差，可移植性接近没有，可读性全靠注释。从软件工程的角度看，这样的代码堪称灾难，这也就是我在上一篇博客中提到的硬件入门难的原因。</p>
<p>因此，库函数应运而生。通过几步简单的封装可以大幅提升代码质量。</p>
<p>首先，给内存地址起个别名:</p>
<pre><code>#define *(unsigned int *)内存地址0 CLOCK_SETTING
#define *(unsigned int *)内存地址1 GPIO_MODE
......
</code></pre><p>这样做的好处有两个：一是增强可读性，二是将与芯片内存映射规则的耦合从主代码逻辑移动到了宏定义头文件中。</p>
<p>其次，将赋值操作封装为函数：</p>
<pre><code>void SetGPIO(byte io, byte pin, byte set_or_reset)
&#123;
    ......
    //执行具体寄存器操作
&#125;
</code></pre><p>前面说过查阅文档主要是为了了解两个问题：操控哪里和怎么操控。宏定义解决操控哪里的问题，函数定义解决如何操控。通过这两个封装，我们可以省略掉对于STM32文档的查阅过程，取而代之的是查阅相应的库函数文档。同样是文档，具体的函数比位定义要清晰简洁多了。</p>
<p>可读性是一方面，封装的另一个更重要的作用是将变化的部分解耦，提升可移植性。对于硬件平台A，我们在函数库A中定义了SetGPIO；对于硬件平台B，只需要根据其硬件结构设计一个函数库B，我们就能通过简单地替换函数库，在不动主逻辑的情况下完成代码移植。</p>
<p>问题在于：硬件平台A与硬件平台B的公司很可能不是同一家，公司B定义的对应函数名不叫SetGPIO怎么办？解决方案也有，我们可以在其上再添加一层封装，屏蔽掉函数名的变化，增加一个跨平台层的函数库。</p>
<p>另一个解决方案是制定一个标准，使各个公司尽量使用同样的函数原型定义。标准由谁来制定？CPU内核设计者ARM再合适不过，于是CMSIS诞生了。</p>
<p>有了上述封装与标准制定，我们终于可以摆脱芯片手册，专注于业务逻辑了。</p>
<p>但是优化空间仍然存在。经过一段时间的开发，我们发现每个工程都有着相似的初始化流程：选定芯片型号，导入函数库，时钟树初始化，相关外设初始化，编写具体的业务逻辑。除了业务逻辑，前面的部分属于重复劳动工作，但又不能省略。怎么封装这部分工作？答案是通过图形化界面，于是CubeMX诞生了。</p>
<hr>
<h2 id="踩坑与教训"><a href="#踩坑与教训" class="headerlink" title="踩坑与教训"></a>踩坑与教训</h2><ol>
<li>在开发时通常使用USB转串口模块与开发板进行通信/程序烧录，但是要注意功率问题。其一是笔记本在没有接通电源时的功率问题，其二是使用USB-HUB时，多个板子的功率都要通过同一个USB口传输，可能会导致功率不足。我花费了大约十几个小时寻找串口通信只能单向传输数据的问题，程序和CubeMX配置来来回回看了无数次，最后的解决方案是给芯片单独接一个USB口。</li>
</ol>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>先说说STM32的教程。</p>
<p>虽然说相关教程铺天盖地，但是能看的教程真的没几个。包括正点、普中、野火等厂商，看得出来授课老师是水平很高的硬件工程师，但他们不是一个好的老师。标题写着零基础入门，但我一个计科专业的学生看得云里雾里。</p>
<p>除了编程语法和数电模电的部分看起来没有压力，其他的部分我始终不能理解。什么时候该看原理图？什么时候该打开芯片手册？应该查哪个部分？为什么突然跳到这个寄存器的部分了？这些关键的东西完全没有提及。</p>
<p>我一直有着这样的观点：从设计者的角度出发，你才能真正理解一个工具的用途。因此，了解技术的发展史很有必要，而这正是大部分教程所欠缺的，也是本篇博客集中探讨的角度。</p>
<p>在这里安利一下海创电子的教程。光是GPIO就讲了将近10节，以GPIO为例详细描述了STM32编程的发展历史，给我带来了很大的帮助。本篇博客的部分内容来源于此，并添加了一些我自己的见解与补充。</p>
<p>再谈谈单片机发展的方向。</p>
<p>计算机技术的核心思想是什么？任何一个计科专业的学生都会不假思索地告诉你：是抽象与封装。虽然没有一本课本明确提出这个观点，但是每一本课本的每一章每一页都在反复述说这个事实。在摩尔定律的加持下，封装带来的有限的性能损失可以忽略不计，从而抽象的层级也越来越高。寄存器到库函数与GUI只是这个趋势下一个微不足道的缩影。</p>
<p>令人不解的是，每个新工具，新封装层级的出现都会有人批判，经典言论有“winform拖控件也算写代码？”“用CubeMX就是偷懒，硬件工程师必须了解寄存器”“大牛们都用命令行编译程序，用IDE怎么能了解编译链接过程呢”。</p>
<p>然而最后人们还是会选择能够提升生产力的工具，逐渐忽略底层逻辑，需要用到的时候再去深入了解，历史一次次地证明了这种方式的正确性。在摩尔定律油尽灯枯之前，这种正确性会一直持续下去。</p>
<p>单片机的抽象层级目前已经发展到oop与微型操作系统，这表现出了另一个趋势：单片机与PC之间的差异正在模糊。从麦金托什的年代到现在，PC的技术栈结构并没有太大的变化。如果将技术栈比作一个光谱，那么PC软件开发占据的位置始终是网络+操作系统+高级编程语言这一层级。而单片机的技术栈光谱已经从电路-&gt;计组-&gt;微原-&gt;c语言一路延申到了操作系统与高级编程语言层级，技术栈间的空白正在消融，两个波段正在逐渐接合。</p>
<p>那时的高性能芯片嵌入式开发也许更像是一个定制化的PC？总之必然与现在的嵌入式开发技术截然不同。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/stm32_0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/15/stm32_0/" class="post-title-link" itemprop="url">STM32学习笔记_0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-15 14:15:00" itemprop="dateCreated datePublished" datetime="2022-03-15T14:15:00+08:00">2022-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 02:12:24" itemprop="dateModified" datetime="2022-03-21T02:12:24+08:00">2022-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>毕设要用到stm32。第一次接触硬件，磕磕绊绊几天后觉得还是得做点笔记记录一下。</p>
<hr>
<h2 id="技术栈结构"><a href="#技术栈结构" class="headerlink" title="技术栈结构"></a>技术栈结构</h2><p>我用作学习的是普中的stm32f103Z400开发板，加上一系列外设。其封装主要为三层：</p>
<h3 id="1-内核层"><a href="#1-内核层" class="headerlink" title="1. 内核层"></a>1. 内核层</h3><p>由ARM公司设计的基于Cortex架构的CPU内核，决定了指令集与CPU功耗、主频等信息。同时集成了调试电路，NVIC中断控制器等基本外设。</p>
<p>参考资料：CortexM3权威指南。</p>
<h3 id="2-单片机层"><a href="#2-单片机层" class="headerlink" title="2. 单片机层"></a>2. 单片机层</h3><p>由ST公司对CPU内核进一步封装，集成了SRAM/Flash等基本外设，构成了一个完整的计算机系统（亦即单片机），这也是主要学习的部分。</p>
<p>参考资料：stm32f10xx芯片手册，stm32f10xx库函数手册。</p>
<h3 id="3-开发板层"><a href="#3-开发板层" class="headerlink" title="3. 开发板层"></a>3. 开发板层</h3><p>添加电源/调试接口/复位电路等电路构成最小系统，并进一步添加外部SRAM/FLASH，蓝牙，LED指示灯等外设（取决于具体开发板厂商）并将引脚接出，构成了一个真正可用的计算机。</p>
<p>参考资料：开发板原理图。</p>
<p>注：在代码结构中，一般也会将不同层级的代码放在不同的文件夹下。</p>
<hr>
<h2 id="Stm32基本结构"><a href="#Stm32基本结构" class="headerlink" title="Stm32基本结构"></a>Stm32基本结构</h2><h3 id="1-内存映射"><a href="#1-内存映射" class="headerlink" title="1. 内存映射"></a>1. 内存映射</h3><p>stm32采用内存与外设统一编址，通过为内存地址赋值的方式设置外设的寄存器，进而控制外设。</p>
<h3 id="2-时钟树"><a href="#2-时钟树" class="headerlink" title="2. 时钟树"></a>2. 时钟树</h3><p>除了cpu外，外设也需要时钟控制。但为了节省能耗，外设的时钟默认处于关闭状态，要使用某一个外设必须使能对应的时钟并为其配置合适的频率。</p>
<p>STM32编程的本质就是通过为内存地址赋值的方式控制挂载在总线上的外设寄存器，进而控制外设。</p>
<hr>
<h2 id="踩坑与教训"><a href="#踩坑与教训" class="headerlink" title="踩坑与教训"></a>踩坑与教训</h2><ol>
<li>开发板上有两个usb接口，其中一个是USB Slave口（暂时没用到不太清楚是干什么的），烧录程序需要通过另一个口（USB转串口模块）。</li>
<li>ch340死活识别不了，装驱动装了三四个小时，最后换了一根usb线，遂解决。</li>
<li>还有挺多，想到再写。</li>
</ol>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>先谈谈STM32的学习。</p>
<p>我向来不喜欢硬件，因为其学习曲线过于陡峭。譬如我要学习c++，只需要了解其基本类型与运算符/变量定义/分支与循环结构/函数定义等为数不多的语法内容，再有几个简单API（printf/scanf之类），前后不超过半小时我就拥有了编写贪吃蛇/2048等小游戏的能力。然而对于单片机，以stm32为例，如果我作为新手，在所有环境配置好的情况下，仅仅是点亮一个led，我需要：</p>
<ol>
<li>了解STM32的内存映射，时钟树结构（微原/计组基础）；</li>
<li>翻阅开发板原理图，找到想要点亮的LED灯，找到其对应的管脚；</li>
<li>翻阅STM32手册，找到对应的GPIO部分（假设我已经对GPIO有所了解），找到对应的时钟，找到时钟使能对应的寄存器；</li>
<li>翻阅手册，了解GPIO电路（模电基础），了解GPIO各个寄存器的作用，找到所需寄存器的基址/偏移；</li>
<li>编码，即使能时钟并设置IO口为低电平;</li>
<li>了解下载与调试电路并正确连接（不要觉得这个无所谓，我一开始甚至试图用普中的一键ISP去给一个最小系统板烧hex文件）；</li>
<li>编译运行。</li>
</ol>
<p>新手显然不可能独立完成上述步骤，只能先跟着教程一步步走完，在之后的学习中再慢慢理解每一步的作用。</p>
<p>对于软件技术，其开发呈现倒金字塔结构：有限的API支撑着庞大的业务逻辑，其复杂性主要体现在业务逻辑中。而对于硬件技术，其开发则呈正金字塔状：有限的业务逻辑下是大量的硬件结构与协议，开发新功能的时间里有百分之八十是在看新模块的硬件资料文档。</p>
<p>上述说法当然存在着一定的局限性：c++提供的接口没有十年的学习不敢说精通，而单片机上的操作系统其逻辑复杂度也堪称恐怖。但是就本科阶段的学习与开发而言，简单粗暴的“金字塔论”能够描述绝大多数人的情况。</p>
<p>造成上述差异的原因是什么？是什么导致了我不能通过一行 SetGPIO(GPIO_C,13, 0) 来控制led？</p>
<p>细说起来有些复杂，明天继续写吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/27/hello_world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="欧泡果奶欧欧欧">
      <meta itemprop="description" content="记录一些想法和技术问题">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧泡的摸鱼日记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/27/hello_world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-27 23:43:00" itemprop="dateCreated datePublished" datetime="2022-01-27T23:43:00+08:00">2022-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-20 23:05:30" itemprop="dateModified" datetime="2022-03-20T23:05:30+08:00">2022-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">杂谈</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　博客丢下了一年，有很多想法、很多技术内容希望找个地方记录一下，也作为一种日志，留给几年后的自己看。知乎简书之类的地方不错，但是我又不希望有很多陌生人来看；U盘里随便找个地方不错，但我又希望能随时向别人分享。真是奇怪的心理，哈哈。</p>
<p>　　可能这就是博客这种东西存在的意义吧。</p>
<p>　　于是我从积灰的文件夹里翻出以前的博客——好家伙，菜得不忍直视，都是些什么乱七八糟的东西。</p>
<p>　　太菜了，我立刻删了个干净。</p>
<p>　　从头开始，随时记录一些思考，一些技术问题，一些学习过程中的心得感悟。</p>
<p>　　希望这次能坚持得久一些吧^_^。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">欧泡果奶欧欧欧</p>
  <div class="site-description" itemprop="description">记录一些想法和技术问题</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">欧泡果奶欧欧欧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
